<html><body bgcolor="#000000" text="#ffffff"><table><tr><td colspan="2"><h3>Problem Statement</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><p>Many monetary systems have the nice property that, when giving change, a greedy algorithm will always produce the fewest number of coins possible.  In other words, if you are trying to produce a certain <i>amount</i> of change, then something like the following algorithm will produce the fewest coins possible:</p>
<pre>
number of coins = 0;
while(amount&gt;0){
	find the largest coin, c, that is less than or equal to amount;
	subtract the value of c from amount and increment the number of coins;
}
</pre>
<p>For example, the American monetary system with coins valued at 1, 5, 10, and 25 cents has this property.  However, it is not difficult to construct values of coins that do not have this property.  If the values of your coins are 1, 3 and 4, then you can make 6 with two 3's.  The algorithm above, on the other hand, will use 3 coins - a 4 and two 1's.</p>
<p>Your task is to write a class GreedyChange, with a method smallest that takes a int[], <b>denominations</b>, representing the values of the various coins in some monetary system.  You should return the smallest amount of money for which the greedy algorithm does not produce the fewest coins possible.  If the greedy algorithm always produces the fewest coins possible, return -1.  To guarantee that the greedy algorithm always works (terminates), there will always be a coin worth 1.</p></td></tr><tr><td colspan="2"><h3>Definition</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td>Class:</td><td>GreedyChange</td></tr><tr><td>Method:</td><td>smallest</td></tr><tr><td>Parameters:</td><td>int[]</td></tr><tr><td>Returns:</td><td>int</td></tr><tr><td>Method signature:</td><td>int smallest(int[] denominations)</td></tr><tr><td colspan="2">(be sure your method is public)</td></tr></table></td></tr><tr><td>&#160;&#160;&#160;&#160;</td></tr><tr><td></td></tr><tr><td colspan="2"><h3>Constraints</h3></td></tr><tr><td align="center" valign="top">-</td><td><b>denominations</b> will contain between 1 and 50 elements, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td>Each element of <b>denominations</b> will be between 1 and 500,000, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td>At least one of the elements of <b>denominations</b> will be 1.</td></tr><tr><td colspan="2"><h3>Examples</h3></td></tr><tr><td align="center" nowrap="true">0)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{1,25,10,5}</pre></td></tr></table></td></tr><tr><td><pre>Returns: -1</pre></td></tr><tr><td><table><tr><td colspan="2">In this system, the greedy algorithm always produces an optimal result.</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">1)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{1,3,4}</pre></td></tr></table></td></tr><tr><td><pre>Returns: 6</pre></td></tr><tr><td><table><tr><td colspan="2">If we need to make 6, the greedy algorithm does so as 4 + 1 + 1.  However, the optimal solution is 3 + 3.</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">2)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{1,10,10,20,25}</pre></td></tr></table></td></tr><tr><td><pre>Returns: 30</pre></td></tr><tr><td><table><tr><td colspan="2">Note that elements may be repeated.</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">3)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{1,15,25}</pre></td></tr></table></td></tr><tr><td><pre>Returns: 30</pre></td></tr><tr><td></td></tr></table></td></tr><tr><td align="center" nowrap="true">4)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{1,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,
52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,500000}</pre></td></tr></table></td></tr><tr><td><pre>Returns: -1</pre></td></tr><tr><td></td></tr></table></td></tr><tr><td align="center" nowrap="true">5)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{500000,499999,1}</pre></td></tr></table></td></tr><tr><td><pre>Returns: 999998</pre></td></tr><tr><td></td></tr></table></td></tr></table><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc.  Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited.  (c)2003, TopCoder, Inc.  All rights reserved.  </p></body></html>
